[1mdiff --git a/services/application_check_submit_service.py b/services/application_check_submit_service.py[m
[1mindex 7900376..005ded4 100644[m
[1m--- a/services/application_check_submit_service.py[m
[1m+++ b/services/application_check_submit_service.py[m
[36m@@ -1,3 +1,6 @@[m
[32m+[m[32m# services/application_check_submit_service.py[m
[32m+[m
[32m+[m[32mfrom datetime import datetime[m
 from models import ([m
     db,[m
     ClubApplicationQuestion,[m
[36m@@ -8,104 +11,136 @@[m [mfrom models import ([m
 )[m
 [m
 [m
[31m-def get_club_application_questions(club_id):[m
[31m-    """특정 동아리의 지원 질문들을 조회"""[m
[32m+[m[32mdef get_club_application_questions(club_id: int):[m
[32m+[m[32m    """특정 동아리의 지원 질문들을 조회 (order 보장)"""[m
     try:[m
[31m-        # 동아리 존재 여부 확인[m
[32m+[m[32m        # 동아리 존재 확인[m
         club = Club.query.get(club_id)[m
         if not club:[m
             raise ValueError("존재하지 않는 동아리입니다")[m
 [m
[31m-        # 해당 동아리의 지원 질문들 조회 (간단한 방식)[m
[31m-        questions = ClubApplicationQuestion.query.filter_by(club_id=club_id).all()[m
[32m+[m[32m        # 질문 조회 (질문 순서 asc)[m
[32m+[m[32m        questions = ([m
[32m+[m[32m            ClubApplicationQuestion.query.filter_by(club_id=club_id)[m
[32m+[m[32m            .order_by(ClubApplicationQuestion.question_order.asc())[m
[32m+[m[32m            .all()[m
[32m+[m[32m        )[m
 [m
         if not questions:[m
             raise ValueError("해당 동아리의 지원 질문이 없습니다")[m
 [m
[31m-        # 수동으로 정렬 (Python에서)[m
[31m-        questions_sorted = sorted(questions, key=lambda q: q.question_order)[m
[31m-[m
[31m-        # JSON 변환[m
         return [[m
             {[m
[31m-                "id": question.id,[m
[31m-                "question_text": question.question_text,[m
[31m-                "question_order": question.question_order,[m
[32m+[m[32m                "id": q.id,[m
[32m+[m[32m                "question_text": q.question_text,[m
[32m+[m[32m                "question_order": q.question_order,[m
             }[m
[31m-            for question in questions_sorted[m
[32m+[m[32m            for q in questions[m
         ][m
 [m
     except ValueError:[m
[31m-        # ValueError는 그대로 전달[m
         raise[m
     except Exception as e:[m
[31m-        # 다른 데이터베이스 오류를 상위로 전달[m
[32m+[m[32m        # 상위 컨트롤러에서 500으로 처리[m
         raise Exception(f"지원 질문 조회 중 오류 발생: {str(e)}")[m
 [m
 [m
[31m-def submit_application(club_id, user_id, answers_data):[m
[31m-    """동아리 지원서 제출"""[m
[32m+[m[32mdef submit_application(club_id: int, user_id: int, answers_data: list[dict]):[m
[32m+[m[32m    """[m
[32m+[m[32m    동아리 지원서 제출[m
[32m+[m[32m    - DB 스키마 준수:[m
[32m+[m[32m      * applications.status: ENUM('SUBMITTED','VIEWED','ACCEPTED','REJECTED')[m
[32m+[m[32m      * applications.submitted_at: TIMESTAMP NOT NULL → 반드시 값 세팅[m
[32m+[m[32m      * application_answers.answer_order: 해당 질문의 question_order와 동일[m
[32m+[m[32m    """[m
     try:[m
[31m-        # 동아리 존재 여부 확인[m
[32m+[m[32m        # --------- 0) 기본 엔터티 검증 ----------[m
         club = Club.query.get(club_id)[m
         if not club:[m
             raise ValueError("존재하지 않는 동아리입니다")[m
 [m
[31m-        # 사용자 존재 여부 확인[m
         user = User.query.get(user_id)[m
         if not user:[m
             raise ValueError("존재하지 않는 사용자입니다")[m
 [m
[31m-        # 이미 지원했는지 확인[m
[32m+[m[32m        # 중복 지원 방지[m
         existing_application = Application.query.filter_by([m
             user_id=user_id, club_id=club_id[m
         ).first()[m
         if existing_application:[m
             raise ValueError("이미 해당 동아리에 지원하셨습니다")[m
 [m
[31m-        # 지원서 생성[m
[32m+[m[32m        # --------- 1) 질문 맵 구성 (id -> question_order) ----------[m
[32m+[m[32m        rows = ([m
[32m+[m[32m            ClubApplicationQuestion.query.filter_by(club_id=club_id)[m
[32m+[m[32m            .with_entities([m
[32m+[m[32m                ClubApplicationQuestion.id, ClubApplicationQuestion.question_order[m
[32m+[m[32m            )[m
[32m+[m[32m            .all()[m
[32m+[m[32m        )[m
[32m+[m[32m        if not rows:[m
[32m+[m[32m            raise ValueError("해당 동아리의 지원 질문이 없습니다")[m
[32m+[m
[32m+[m[32m        q_order_map = {int(qid): int(qorder) for (qid, qorder) in rows}[m
[32m+[m
[32m+[m[32m        # --------- 2) 요청 검증 ----------[m
[32m+[m[32m        seen = set()[m
[32m+[m[32m        for i, a in enumerate(answers_data, start=1):[m
[32m+[m[32m            # 키 존재/타입 최소 검증[m
[32m+[m[32m            if "question_id" not in a:[m
[32m+[m[32m                raise ValueError(f"답변 {i}에 question_id가 필요합니다")[m
[32m+[m[32m            if "answer_text" not in a:[m
[32m+[m[32m                raise ValueError(f"답변 {i}에 answer_text가 필요합니다")[m
[32m+[m
[32m+[m[32m            try:[m
[32m+[m[32m                qid = int(a["question_id"])[m
[32m+[m[32m            except (TypeError, ValueError):[m
[32m+[m[32m                raise ValueError(f"답변 {i}의 question_id 형식이 올바르지 않습니다")[m
[32m+[m
[32m+[m[32m            if qid not in q_order_map:[m
[32m+[m[32m                raise ValueError(f"존재하지 않는 질문입니다: {qid}")[m
[32m+[m
[32m+[m[32m            if qid in seen:[m
[32m+[m[32m                raise ValueError(f"질문 {qid}에 대한 중복 답변이 있습니다")[m
[32m+[m[32m            seen.add(qid)[m
[32m+[m
[32m+[m[32m        # (선택) 모든 질문에 대해 답변을 강제하려면:[m
[32m+[m[32m        # if len(seen) != len(q_order_map):[m
[32m+[m[32m        #     raise ValueError("모든 질문에 대한 답변을 제출해야 합니다")[m
[32m+[m
[32m+[m[32m        # --------- 3) Application 생성 (submitted_at 필수) ----------[m
         new_application = Application([m
             user_id=user_id,[m
             club_id=club_id,[m
[31m-            status="SUBMITTED",  # 기본 상태: 제출됨[m
[32m+[m[32m            status="SUBMITTED",[m
[32m+[m[32m            submitted_at=datetime.utcnow(),  # ✅ TIMESTAMP NOT NULL 충족[m
         )[m
         db.session.add(new_application)[m
[31m-        db.session.flush()  # ID를 얻기 위해 flush[m
[31m-[m
[31m-        # 답변들 저장[m
[31m-        for answer_data in answers_data:[m
[31m-            # 질문 존재 여부 확인[m
[31m-            question = ClubApplicationQuestion.query.filter_by([m
[31m-                id=answer_data["question_id"], club_id=club_id[m
[31m-            ).first()[m
[31m-            if not question:[m
[31m-                raise ValueError(f"존재하지 않는 질문입니다: {answer_data['question_id']}")[m
[31m-[m
[31m-            # 답변 저장[m
[31m-            new_answer = ApplicationAnswer([m
[32m+[m[32m        db.session.flush()  # PK 확보[m
[32m+[m
[32m+[m[32m        # --------- 4) Answer 저장 (order = question_order) ----------[m
[32m+[m[32m        for a in answers_data:[m
[32m+[m[32m            qid = int(a["question_id"])[m
[32m+[m[32m            answer = ApplicationAnswer([m
                 application_id=new_application.id,[m
[31m-                question_id=answer_data["question_id"],[m
[31m-                answer_text=answer_data["answer_text"],[m
[31m-                answer_order=answer_data.get("answer_order", 1),[m
[32m+[m[32m                question_id=qid,[m
[32m+[m[32m                answer_text=a["answer_text"],[m
[32m+[m[32m                answer_order=q_order_map[qid],  # ✅ 스키마 규칙[m
             )[m
[31m-            db.session.add(new_answer)[m
[32m+[m[32m            db.session.add(answer)[m
 [m
[31m-        # 모든 변경사항 커밋[m
[32m+[m[32m        # --------- 5) 커밋 ----------[m
         db.session.commit()[m
 [m
         return {[m
             "application_id": new_application.id,[m
             "status": new_application.status,[m
[31m-            "submitted_at": new_application.submitted_at.isoformat()[m
[31m-            if new_application.submitted_at[m
[31m-            else None,[m
[32m+[m[32m            "submitted_at": new_application.submitted_at.isoformat(),[m
         }[m
 [m
     except ValueError:[m
[31m-        # ValueError는 그대로 전달[m
         db.session.rollback()[m
         raise[m
     except Exception as e:[m
[31m-        # 다른 오류 발생 시 롤백[m
         db.session.rollback()[m
         raise Exception(f"지원서 제출 중 오류 발생: {str(e)}")[m
